<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Didrik Fleischer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css">
    <link href="https://fonts.googleapis.com/css?family=Arvo|Roboto|Italiana" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/portfolio_style.css">
  </head>
  <body>
    <div class="Banner">
      <div class="Banner__frame">
        <img class="Banner__profilepicture" src="../images/profile_picture.png" alt="Profile picture missing">
      </div>

      <div class="Banner__text">
        <h1 class="Banner__heading">DIDRIK FLEISCHER</h1>
        <p class="Banner__subheading">MSc student in industrial economics and</br>aspiring web developer</p>
      </div>


      <nav class="Banner__navigation">
          <ul class="Navigation__list">
            <li class="Navigation__element"><a href="/#home">HOME</a></li>
            <li class="Navigation__element"><a href="/#about">ABOUT</a></li>
            <li class="Navigation__element"><a href="/#portfolio">PORTFOLIO</a></li>
            <li class="Navigation__element"><a href="/#cv">CV</a></li>
            <li class="Navigation__element"><a href="/#contact">CONTACT</a></li>
          </ul>
        </nav>
    </div>

    
    <div class="Project">
      <div class="Project__row">
        <div class="Project__column">
            <a href="/livedemo/ticketbeast"><h1>Ticketbeast - TDD course</h1></a>
            <p>
              Ticketbeast is a course on test driven development (TDD) with Laravel and PHP by Adam Wathan. In the course, students build out a web application where concert promoters can sell tickets, and every line of code is written with the TDD ethos in mind. Every significant behavior of the application is driven out by pre-written tests. Over 3000 lines of test code was written to prove the application is working as intended. Adam Wathan provides many insights into TDD, PHP and Laravel development throughout the course. I found it very engaging and educational to follow along. 
              </br></br>
              To check out the full extent of Ticketbeast’s features, you can log onto a test user with the following credentials: </br>
              Email: user@test.com</br>
              Password: testpass</br></br>
              If you want to try to purchase some tickets, you can do so by using any email address, combined with: </br>
              Card number: 4242 4242 4242 4242</br>
              Expiration date: any date in the future</br>
              CVC: any three-digit number
            
            </p>
        </div>
        <div class="Project__column">
            <a href="/livedemo/ticketbeast"><img src="../images/TicketBeast_frontpage.png" alt="Ticketbeast front page"></a>
          </div>
      </div>
      
      <div >

      </div>
    </div>



    <div class="Features">
      <h2 class="Section__title">Features</h2>
      <p class="Features__paragraph">

        This application allows concert promoters to advertise concerts and sell tickets. The application integrates with Stripe.com, and is developed to be able to take actual payments from credit/debit cards.

      </p>

      <div class="Features__container">
          <div class="Features__element">
              <h3 class="">1. Create, edit and publish concerts</h3>
              <img src="/images/TicketBeast_yourconcerts.png">
              <p class="">
                The site administrator sends an invitation email, using an artisan command. With a link provided in the email, the promoter is able to sign up to the site. When signed in, the promoter is able to add concerts to the system. The concerts stay hidden from others until the promoter is satisfied with the information and decides to publish it. Between the time of creation and publishing, the promoter is able to edit the concert details.
              </p>
          </div>
          <div class="Features__element">
              <h3 class="">2. Sell tickets and take payments</h3>
              <img src="/images/TicketBeast_buytickets.png">
              <p class="">
                Once a concert is published, the public can purchase tickets. The application integrates with Stripe.com, enabling online payments using an OAuth framework. The customer decides how many tickets she wants to buy, enters her credit card information and the rest is handled by stripe. Once the payment has been made successfully, an order for the tickets is created. The customer is redirected to a page showing her tickets, with unique ticket codes. Ticketbeast automatically takes a 10% platform fee, the rest of the money goes directly into the promoter’s Stripe account.
              </p>
          </div>
          <div class="Features__element">
              <h3 class="">3. Concert Management</h3>
              <img src="/images/TicketBeast_ordersummary.png">
              <p class="">
                The promoters can see details like, how many tickets have been purchased, how many are left and how much revenue has been generated. Promoters can also get information about the latest purchases made; who bought the tickets, how many tickets were purchased and so on. I the event a promoter needs to get some information out to all attendees of a concert, she is able to do so from within the application.
              </p>
          </div>
      </div>

    </div>

    <div class="Technologies">
      <div class="Text__container">
          <h2 class="Section__title">Technologies involved</h2>
      
          The Ticketbeast project is all about test driven development (TDD) and the Laravel framework. Very few services and features exogenous to the Laravel ecosystem was used. The notable once was PHPUnit, Stripe and MySQL.</br></br>
          The Ticketbeast application is hosted on the same server as didrikfleischer.com, a t2.micro with Ubuntu on AWS. The site is behind a Nginx http server, configured as a reverse proxy. A local MySQL server is used to provide persistent storage of user data. The source code is written in PHP using the Laravel framework. </br></br>
          Out of the box, Laravel uses PHPUnit as its testing framework. The assertion logic is provided by PHPUnit rather than Laravel itself. Laravel comes with many useful testing features beyond PHPUnit, like; using Mockery to mock objects (like Eloquent models), fakes for many of Laravels core classes and using sqlite as an in-memory database. </br></br>
          Stripe is a software platform for running an internet business. They handle billions of dollars every year. They take care of managing and storing sensitive user data, like credit card information, and interfaces with banks around the world to process payments, transfers, disputes, refunds and much more. By using an OAuth framework, developers can enable their applications to take payments and set up subscriptions, all without having to worry about the regulatory requirements and technicalities of handling and storing sensitive financial data. Ticketbeast use stripe to take payments for concert tickets, pay promoters and gathering platform fees. Since the application is just for show, the API keys in use only support test data. No actual card can be charged without changing the API keys. </br></br>
          Due to me not being able to take much credit for the source code of Ticketbeast, I decided to show my understanding though a compilation of tips and insights I gathered throughout the course. Take a look in the section below. </br></br>
          </br></br>
          
          <h2 class="Section__title">Tips and Insights</h2>
          In this section I list a collection of tips and insights I gathered throughout the Ticketbeast course. I’ve split them into themed sections, but beyond this, there is lack of structure. I understand that many of the point below are a matter of preference and subjective opinion, but I’m going to make them regardless. Often, I won’t get into the details of the point I’m making, keeping it short and sweet (or just wage?). This section is for developer’s eyes. </br></br>
          
          <h3>Test Driven Development and PHPUnit</h3>
          <ul>
            <li>
              The overall approach:
              <ol>
                <li>Fist write a high-level feature test</li>
                <li>Then write unit tests to flush out the feature and get it to a green state</li>
                <li>Unit tests are written to support the higher-level feature test</li>
                <li>Unit tests are written for better feedback when running the tests, and are sort of redundant</li>
                <li>When a unit test is not passing, but our feature test is, then maybe there are something in the unit tests that we are testing for, but do not actually need.</li>
              </ol>
            </li>
            <li>There is a concept of code smells; characteristics of code that is indicative of its bad quality, and that it should be improved. There are many such smells and solutions. A couple of them are: 
              <ul>
                  <li>Long parameter list (one solution is: preserve the whole object)</li>
                  <li>Feature envy; one object is very interested in the internal workings of another object (one solution is: let the object owning all the information do the work the other object wants done)</li>
              </ul>
            </li>
            <li>It can be hard to see if you are not working in a TTD way, but if you get effective with a test library and develop a development flow and environment that allows you to quickly run your tests, working in a TDD way can speed up development and ensure better code.</li>
            <li>When first starting out with a new project, ask yourself; what is the core features of the application? What can be done manually by an administrator and does not need to be implemented right away? start working on the core features of the app as soon as possible.</li>
            <li>All data relevant to the assert step should be explicitly created in the arrange step of the test.</li>
            <li>You might want to revise test method names and scope as you go along</li>
            <li>Don’t add anything to your system without it being forced out by a test. You could run the risk of removing something in the future, and still having your test passing, when the system is in reality broken.</li>
            <li>When adding redundant test coverage due to testing a refactor you are doing, you must weigh the added benefit of more expressive error messages against the cost of a bigger test suite (maintenance cost and time required to run the test).</li>
            <li>You can add methods, used only for testing, to you models. They are going to be somewhere on your codebase anyways.</li>
            <li>Only refactor when your tests are passing.</li>
            <li>Write out all assertions for the logic you want before you start actually implementing the features. The error reported when running the test drives the development of your application.</li>
            <li>Write tests for logic and behavior, not for design decisions or where to sprinkle links etc.</li>
            <li>TDD may not be the best way to drive out static pages. In one of the tutorials, it was decided not to drive out the login page with TDD, and simply scaffolded it out. Tests for the actual login controller was written though, and confirmed that the logic behind logging a user in, was working as expected.</li>
            <li>We don’t worry about asserting what exactly an error string should be, just knowing that it is there is enough. In the end, this is a design decision, that the design team may want to change at any moment.</li>
            <li>A real refectory is introducing changes to your code towards some desired end state while keeping your test passing throughout the process.</li>
            <li>Make sure you have tests proving that you need each piece of code you are writing.</li>
            <li>Don’t mock what you do not own.</li>
              <ul>
                <li>Tests will pass even if you aren’t using the real API correctly.</li>
                <li>Tests can’t be used to confirm that our integration works with the external API if a change is made to that API.</li>
                <li>Tests are coupled to a specific implementation; can’t refactor to use another.</li>
              </ul>
            <li>Use "contract tests” to create a set of tests that are shared between all the different implementations of an interface.</li>
            <li>There are many places where test duplication could occur, keep an eye out for this, so that you don’t make your tests unnecessarily complicated. Code only needs to be tested once.</li>
            <li>You can always comment out a function you suspect you don’t need any more, run the test suite, if all is ok; you can with confidence delete the method. Otherwise, just uncomment it.</li>
            <li>Facades have helper methods to assist with testing: FacadeClass::method()->shouldReceive($methodName)->andReturn($someValue)</li>
            <li>Sometimes it’s better to use mocks and spies to not duplicate tests. Use mocks and spies on your feature tests, making sure that the methods that you intend to be called, are in fact called. Then use unit tests to assert that the behavior of the methods is correct.</li>
            <li>As you mock objects in your code, you come in danger of having the tests around the mocks not represent the real implementations. Mockery enables you to pick up on this by setting a configuration option to not allow mocking non-existing methods. This way, Mockery will tell you whenever you are trying to mock a method that does not exist on the object you are mocking. (Mockery::getConfiguration()->allowMockingNonExistentMethods(false))</li>
            <li>When testing form-submissions you cannot use mocks, but there are still ways to make your tests clearer and more explicit. Use payload factory helper-methods to generate forms (arrays) with valid data that you can override depending on the test.</li>
            <li>Using model factories in your tests will centralize the logic of creating models, making it easy to make changes to how models are created.</li>
            <li>You have to look out for tests for features that could also be solved by code that would not satisfy your needs in production. (Example: scramble database records, to explicitly force the implementation of record filtering, and not allowing a paginated list to also pass the test.)</li>
            <li>Use self-documenting mock data in your tests.</li>
            <li>Use assertArraySubset($arr1, $arr2) whenever you want to assert that all attributes in arr1 is in arr2, but are2 is allowed to have additional fields.</li>
            <li>Get logic out of the views, so that things can be more explicitly tested on the controller level.</li>
            <li>PHPUnit’s assertion signature allows passing in, as the fourth parameter, a parameter specifying the precision floating point numbers should be compared with.</li>
            <li>If a test becomes large and messy, because you have a complicated setup and many assertions, it may be valuable to split the test into two. Hopefully you’ll avoid having to duplicated the complicated setup and still test what you want.</li>
            <li>When testing image processing, and you want to make sure that the resulting image is similar to the original, don’t do some advanced image-comparison operation, just have an image on disk, already processed, that you visually have verified to be correct and assert that this image is the same as the newly processed image.</li>
            <li>For expressiveness, it could be beneficial to; assert on some state, try to perform some action that should fail, then assert that the state is unchanged.</li>
            <li>You can test artisan commands by running them within your test like this: $this->artisan(‘my-command’, [$param1, $param2]), and then assert on the side effects of running the command.</li>
            <li>Mocks and spies can help you with testing classes with methods that have stochastic return values.</li>
            <li>Browser testing with Laravel Dusk (and in general) will not give you fine grained information about server-side errors, and you have to build out a lot of code without errors telling you what to do next. This is a disadvantage, and is one reason why you should test as much as possible with http feature tests.</li>
            <li>You can look in Laravel’s logs for clues to why your Dusk tests are failing.</li>
            <li>You can unit test middleware, I especially liked the trick with a custom next() function passed to the middleware’s handle function, where you can fail the test if the function is called.</li>
            <li>When testing, don’t’ hash stuff, don’t do use any cryptographic functions in your test suite. Avoiding them can dramatically decrease your tests run time, if you use them many places (hashing passwords in User model factory for instance).</li>
          </ul>
          <h3>PHP and Laravel</h3>
          <ul>
            <li>A lot of code is related to the models, so it’s not strange that the models get quite big.</li>
            <li>model->findOrFail() causes a ModelNotFoundException, if no model was retrieved from the database. Laravel will automatically turn this into a 404 response.</li>
            <li>Return $this in model methods to be able to chain the method with others.</li>
            <li>You can chain catch-clauses to conditionally handle different Exceptions thrown in the try block.</li>
            <li>Use seeJsonSubset() to assert that JSON matches some array.</li>
            <li>Often interfaces are bound to implementations in the IOC container.</li>
            <li>Laravel’s collections are very powerful, being fluent with them is a major advantage.</li>
            <li>Several of Laravel’s classes are macroable, this has many potential uses (make things read nicer, etc…)</li>
            <li>Although the concurrency model in PHP is dead simple, race condition still occur; watch out!</li>
            <li>You can create helper methods on the base TestCase class. This can aid when refactoring, because you’ll have centralized some of the logic. </li>
            <li>You can create custom Model Factory Classes, but then you should put them directly under the database folder and not under database/factories, because of how Laravel automatically loads files in this directory. </li>
            <li>Writing tests that forces controllers to return views, will catch errors in the views and report them. You get this feedback "for free”.</li>
            <li>Using a table as a pivot table between two other tables (expressing a one-to-many relationship though a third table), requires that the pivot table has only one entry for each pair of ids from the two tables being connected. (Eloquent related)</li>
            <li>Laravel provides helpers for mocking events, jobs, and facades out of the box. These helpers primarily provide a convenience layer over Mockery so you do not have to manually make complicated Mockery method calls. Of course, you are free to use Mockery or PHPUnit to create your own mocks or spies.</li>
            <li>Testing queues: you test that the controller actually dispatches the job with the correct data passed to it, and then write a separate unit test to drive out the actual implementation of the handle() method of the job.</li>
            <li>Maybe don’t generalize in your test function names: prefer “a_promoter_cannot_send_a_new_message_for_other_concerts”, over  “promoters_cannot_send_new_messages_for_other_concerts”. The application is at any time only concerned with individual promoters and individual messages (just a thought).</li>
            <li>Once you have a successfully passing test, to check if your implementation works as intended, make a breaking change and see the test failing. An additional indication that your code works as expected.</li>
            <li>Laravel comes with built in ways to generate fake files and images.</li>
            <li>Many things your controllers should not know about. It’s a bad habit to clutter down your controllers with all sorts of logic. Laravel has an event system that can be used to alleviate this problem.</li>
            <li>You can act as a user when performing a request to your application within your tests, using the actingAs($user) method.</li>
            <li>Laravel allows you to mock the Storage class, which can fake integrations with cloud storage providers. Laravel creates local folders where the files you upload actually gets stored, so that assertions can be made against the actual files, stored on your local file system. This way you don’t need to interface with something like S3 when running your tests.</li>
            <li>Using Intervention-image, you can resize the image, while maintaining the aspect ratio, limit the amount of colors and encode it in different formats in a few lines of code. An image can get 10x smaller, boosting performance.</li>
            <li>In PHP you can create callable classes using the __invoke() magic method on the class. This allows you to capture information about the method call, like; parameters it was called with, if it was in fact called, and more.</li>
            <li>Composer’s autoloader resolves and loads the file that a class is located in, but the Laravel service container is still needed to tell the application what implementation/instance of the class to use. The class may have a constructor taking any number of arguments, composer’s autoloader has no way of knowing what arguments this should be.</li>
          </ul>
          <h3>Web Development and Programming in General</h3>
          <ul>
            <li>Think about the order of failure conditions you want your users to be reported about. (403, then 302, then 404 for instance)</li>
            <li>A 404 should take precedence over a 422</li>
            <li>Redirect before reporting Not Found (302 take precedence over 404), this is to not leak information about assets to users who does not own that asset.</li>
            <li>Interfaces are not enough to ensure multiple implementations of the same interface actually behave the same way from the point of view of the rest of the application.</li>
            <li>Domain logic should ideally be located in one place only.</li>
            <li>Catch and re-throw Exceptions thrown by external library, to insulate your application from needing to know about the internal working is the external library and its dependencies.</li>
            <li>Good object-oriented design really helps with structure and maintainability.</li>
            <li>Devoting some time to how the objects in your app are composed together can really help with your design.</li>
            <li>Use the Hashids library to generate short, “random" and non-colliding strings.</li>
            <li>It could be beneficial to keep your controllers very REST and resource oriented, only allowing methods like: index, show, create, store, edit, update, delete. Not allowing all kinds of method names will keep you from having your controllers turn into junk drawers, containing all sorts of logic. Another option is to piggyback whatever you want to do on the resource-oriented methods (that are allowed and already in place). This introduces some complexity, with multiple conditional flows through these methods. A second, and maybe the best way, is to expose a new endpoint representing a new type of resource. Although technically no new resource was created, you only define some state of an already existing resource to be a new resource (published-concerts vs concerts, a published-concert can be defined as a new resource, although there is no model for published-concerts). With this new resource, you can continue to use the resource-oriented method names, and it would read well and be organized. </li>
            <li>You can in your code write method calls and use variables/properties you wish you had, and let the errors occurring when running your test force you to implement them. A powerful way to work, conducive to production of well structured, easy reading code.</li>
            <li>Working with extremely large database results, you might run out of memory; chunking to the rescue.</li>
            <li>With a comprehensive test suite, updating the framework, or other dependencies you are working with, is easy. You update your dependencies in the composer.json file, run composer update, run your test suite and resolve any errors you get. </li>
          </ul>

      </div>
    </div>


    <div class="Learned">
      <h2 class="Section__title">Conclusion</h2>
      <div class="Text__container">
        I have been in the “virtual presence” of a true PHP and Laravel master. It was engaging and interesting to follow along Adam Wathan’s thought processes when building out a real, production ready application. After seeing how TDD can be applied to the development workflow, I will strive to adopt the approach into my future projects. Writing tests introduces, in some ways, more complexity into the workflow, and higher demands on the developers. A testing framework and assertion library must be mastered and the TDD way of working must be adapted to. Although this can be challenging, I do believe the grass is greener on the other side.
      </div>
    </div>


    <footer class="Footer">
      <p class="Footer__thanks">Thank you for taking a look!</p>

      <nav class="Footer__navigation">
        <ul class="Navigation__list">
            <li class="Navigation__element"><a href="/#home">HOME</a></li>
            <li class="Navigation__element"><a href="/#about">ABOUT</a></li>
            <li class="Navigation__element"><a href="/#portfolio">PORTFOLIO</a></li>
            <li class="Navigation__element"><a href="/#cv">CV</a></li>
            <li class="Navigation__element"><a href="/#contact">CONTACT</a></li>
        </ul>
      </nav>

      <p class="Footer__createdby">Created by Didrik Fleischer</p>


      <div class="Footer__links">
          <a target="_blank" rel="noopener noreferrer" href="https://www.facebook.com/didrik.fleischer"><i class="fab fa-facebook-square"></i></a>
          <a target="_blank" rel="noopener noreferrer" href="https://www.linkedin.com/in/didrik-fleischer-a6623533/"><i class="fab fa-linkedin"></i></a>
          <a target="_blank" rel="noopener noreferrer" href="https://github.com/DidrikF"><i class="fab fa-github-square"></i></a>
          <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/FleischerDidrik"><i class="fab fa-twitter-square"></i></a>
      </div>

    </footer>
  </body>
</html>